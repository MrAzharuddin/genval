// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go sigs.k8s.io/cluster-api/api/v1alpha4

package v1alpha4

import (
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	capierrors "sigs.k8s.io/cluster-api/errors"
)

// ClusterFinalizer is the finalizer used by the cluster controller to
// cleanup the cluster resources when a Cluster is being deleted.
#ClusterFinalizer: "cluster.cluster.x-k8s.io"

// ClusterSpec defines the desired state of Cluster.
#ClusterSpec: {
	// Paused can be used to prevent controllers from processing the Cluster and all its associated objects.
	// +optional
	paused?: bool @go(Paused)

	// Cluster network configuration.
	// +optional
	clusterNetwork?: null | #ClusterNetwork @go(ClusterNetwork,*ClusterNetwork)

	// ControlPlaneEndpoint represents the endpoint used to communicate with the control plane.
	// +optional
	controlPlaneEndpoint: #APIEndpoint @go(ControlPlaneEndpoint)

	// ControlPlaneRef is an optional reference to a provider-specific resource that holds
	// the details for provisioning the Control Plane for a Cluster.
	// +optional
	controlPlaneRef?: null | corev1.#ObjectReference @go(ControlPlaneRef,*corev1.ObjectReference)

	// InfrastructureRef is a reference to a provider-specific resource that holds the details
	// for provisioning infrastructure for a cluster in said provider.
	// +optional
	infrastructureRef?: null | corev1.#ObjectReference @go(InfrastructureRef,*corev1.ObjectReference)

	// This encapsulates the topology for the cluster.
	// NOTE: It is required to enable the ClusterTopology
	// feature gate flag to activate managed topologies support;
	// this feature is highly experimental, and parts of it might still be not implemented.
	// +optional
	topology?: null | #Topology @go(Topology,*Topology)
}

// Topology encapsulates the information of the managed resources.
#Topology: {
	// The name of the ClusterClass object to create the topology.
	class: string @go(Class)

	// The Kubernetes version of the cluster.
	version: string @go(Version)

	// RolloutAfter performs a rollout of the entire cluster one component at a time,
	// control plane first and then machine deployments.
	// +optional
	rolloutAfter?: null | metav1.#Time @go(RolloutAfter,*metav1.Time)

	// ControlPlane describes the cluster control plane.
	// +optional
	controlPlane: #ControlPlaneTopology @go(ControlPlane)

	// Workers encapsulates the different constructs that form the worker nodes
	// for the cluster.
	// +optional
	workers?: null | #WorkersTopology @go(Workers,*WorkersTopology)
}

// ControlPlaneTopology specifies the parameters for the control plane nodes in the cluster.
#ControlPlaneTopology: {
	// Metadata is the metadata applied to the machines of the ControlPlane.
	// At runtime this metadata is merged with the corresponding metadata from the ClusterClass.
	//
	// This field is supported if and only if the control plane provider template
	// referenced in the ClusterClass is Machine based.
	metadata?: #ObjectMeta @go(Metadata)

	// Replicas is the number of control plane nodes.
	// If the value is nil, the ControlPlane object is created without the number of Replicas
	// and it's assumed that the control plane controller does not implement support for this field.
	// When specified against a control plane provider that lacks support for this field, this value will be ignored.
	// +optional
	replicas?: null | int32 @go(Replicas,*int32)
}

// WorkersTopology represents the different sets of worker nodes in the cluster.
#WorkersTopology: {
	// MachineDeployments is a list of machine deployments in the cluster.
	machineDeployments?: [...#MachineDeploymentTopology] @go(MachineDeployments,[]MachineDeploymentTopology)
}

// MachineDeploymentTopology specifies the different parameters for a set of worker nodes in the topology.
// This set of nodes is managed by a MachineDeployment object whose lifecycle is managed by the Cluster controller.
#MachineDeploymentTopology: {
	// Metadata is the metadata applied to the machines of the MachineDeployment.
	// At runtime this metadata is merged with the corresponding metadata from the ClusterClass.
	metadata?: #ObjectMeta @go(Metadata)

	// Class is the name of the MachineDeploymentClass used to create the set of worker nodes.
	// This should match one of the deployment classes defined in the ClusterClass object
	// mentioned in the `Cluster.Spec.Class` field.
	class: string @go(Class)

	// Name is the unique identifier for this MachineDeploymentTopology.
	// The value is used with other unique identifiers to create a MachineDeployment's Name
	// (e.g. cluster's name, etc). In case the name is greater than the allowed maximum length,
	// the values are hashed together.
	name: string @go(Name)

	// Replicas is the number of worker nodes belonging to this set.
	// If the value is nil, the MachineDeployment is created without the number of Replicas (defaulting to zero)
	// and it's assumed that an external entity (like cluster autoscaler) is responsible for the management
	// of this value.
	// +optional
	replicas?: null | int32 @go(Replicas,*int32)
}

// ClusterNetwork specifies the different networking
// parameters for a cluster.
#ClusterNetwork: {
	// APIServerPort specifies the port the API Server should bind to.
	// Defaults to 6443.
	// +optional
	apiServerPort?: null | int32 @go(APIServerPort,*int32)

	// The network ranges from which service VIPs are allocated.
	// +optional
	services?: null | #NetworkRanges @go(Services,*NetworkRanges)

	// The network ranges from which Pod networks are allocated.
	// +optional
	pods?: null | #NetworkRanges @go(Pods,*NetworkRanges)

	// Domain name for services.
	// +optional
	serviceDomain?: string @go(ServiceDomain)
}

// NetworkRanges represents ranges of network addresses.
#NetworkRanges: {
	cidrBlocks: [...string] @go(CIDRBlocks,[]string)
}

// ClusterStatus defines the observed state of Cluster.
#ClusterStatus: {
	// FailureDomains is a slice of failure domain objects synced from the infrastructure provider.
	failureDomains?: #FailureDomains @go(FailureDomains)

	// FailureReason indicates that there is a fatal problem reconciling the
	// state, and will be set to a token value suitable for
	// programmatic interpretation.
	// +optional
	failureReason?: null | capierrors.#ClusterStatusError @go(FailureReason,*capierrors.ClusterStatusError)

	// FailureMessage indicates that there is a fatal problem reconciling the
	// state, and will be set to a descriptive error message.
	// +optional
	failureMessage?: null | string @go(FailureMessage,*string)

	// Phase represents the current phase of cluster actuation.
	// E.g. Pending, Running, Terminating, Failed etc.
	// +optional
	phase?: string @go(Phase)

	// InfrastructureReady is the state of the infrastructure provider.
	// +optional
	infrastructureReady: bool @go(InfrastructureReady)

	// ControlPlaneReady defines if the control plane is ready.
	// +optional
	controlPlaneReady?: bool @go(ControlPlaneReady)

	// Conditions defines current service state of the cluster.
	// +optional
	conditions?: #Conditions @go(Conditions)

	// ObservedGeneration is the latest generation observed by the controller.
	// +optional
	observedGeneration?: int64 @go(ObservedGeneration)
}

// APIEndpoint represents a reachable Kubernetes API endpoint.
#APIEndpoint: {
	// The hostname on which the API server is serving.
	host: string @go(Host)

	// The port on which the API server is serving.
	port: int32 @go(Port)
}

// Cluster is the Schema for the clusters API.
//
// Deprecated: This type will be removed in one of the next releases.
#Cluster: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)
	spec?:     #ClusterSpec       @go(Spec)
	status?:   #ClusterStatus     @go(Status)
}

// ClusterIPFamily defines the types of supported IP families.
#ClusterIPFamily: int // #enumClusterIPFamily

#enumClusterIPFamily:
	#InvalidIPFamily |
	#IPv4IPFamily |
	#IPv6IPFamily |
	#DualStackIPFamily

#values_ClusterIPFamily: {
	InvalidIPFamily:   #InvalidIPFamily
	IPv4IPFamily:      #IPv4IPFamily
	IPv6IPFamily:      #IPv6IPFamily
	DualStackIPFamily: #DualStackIPFamily
}

#InvalidIPFamily:   #ClusterIPFamily & 0
#IPv4IPFamily:      #ClusterIPFamily & 1
#IPv6IPFamily:      #ClusterIPFamily & 2
#DualStackIPFamily: #ClusterIPFamily & 3

// ClusterList contains a list of Cluster.
//
// Deprecated: This type will be removed in one of the next releases.
#ClusterList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#Cluster] @go(Items,[]Cluster)
}

// FailureDomains is a slice of FailureDomains.
#FailureDomains: {[string]: #FailureDomainSpec}

// FailureDomainSpec is the Schema for Cluster API failure domains.
// It allows controllers to understand how many failure domains a cluster can optionally span across.
#FailureDomainSpec: {
	// ControlPlane determines if this failure domain is suitable for use by control plane machines.
	// +optional
	controlPlane: bool @go(ControlPlane)

	// Attributes is a free form map of attributes an infrastructure provider might use or require.
	// +optional
	attributes?: {[string]: string} @go(Attributes,map[string]string)
}
