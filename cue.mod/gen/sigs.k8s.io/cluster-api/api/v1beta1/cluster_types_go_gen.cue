// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go sigs.k8s.io/cluster-api/api/v1beta1

package v1beta1

import (
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	apiextensionsv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	capierrors "sigs.k8s.io/cluster-api/errors"
)

// ClusterFinalizer is the finalizer used by the cluster controller to
// cleanup the cluster resources when a Cluster is being deleted.
#ClusterFinalizer: "cluster.cluster.x-k8s.io"

// ClusterKind represents the Kind of Cluster.
#ClusterKind: "Cluster"

// ClusterSpec defines the desired state of Cluster.
#ClusterSpec: {
	// Paused can be used to prevent controllers from processing the Cluster and all its associated objects.
	// +optional
	paused?: bool @go(Paused)

	// Cluster network configuration.
	// +optional
	clusterNetwork?: null | #ClusterNetwork @go(ClusterNetwork,*ClusterNetwork)

	// ControlPlaneEndpoint represents the endpoint used to communicate with the control plane.
	// +optional
	controlPlaneEndpoint?: #APIEndpoint @go(ControlPlaneEndpoint)

	// ControlPlaneRef is an optional reference to a provider-specific resource that holds
	// the details for provisioning the Control Plane for a Cluster.
	// +optional
	controlPlaneRef?: null | corev1.#ObjectReference @go(ControlPlaneRef,*corev1.ObjectReference)

	// InfrastructureRef is a reference to a provider-specific resource that holds the details
	// for provisioning infrastructure for a cluster in said provider.
	// +optional
	infrastructureRef?: null | corev1.#ObjectReference @go(InfrastructureRef,*corev1.ObjectReference)

	// This encapsulates the topology for the cluster.
	// NOTE: It is required to enable the ClusterTopology
	// feature gate flag to activate managed topologies support;
	// this feature is highly experimental, and parts of it might still be not implemented.
	// +optional
	topology?: null | #Topology @go(Topology,*Topology)
}

// Topology encapsulates the information of the managed resources.
#Topology: {
	// The name of the ClusterClass object to create the topology.
	class: string @go(Class)

	// The Kubernetes version of the cluster.
	version: string @go(Version)

	// RolloutAfter performs a rollout of the entire cluster one component at a time,
	// control plane first and then machine deployments.
	//
	// Deprecated: This field has no function and is going to be removed in the next apiVersion.
	//
	// +optional
	rolloutAfter?: null | metav1.#Time @go(RolloutAfter,*metav1.Time)

	// ControlPlane describes the cluster control plane.
	// +optional
	controlPlane?: #ControlPlaneTopology @go(ControlPlane)

	// Workers encapsulates the different constructs that form the worker nodes
	// for the cluster.
	// +optional
	workers?: null | #WorkersTopology @go(Workers,*WorkersTopology)

	// Variables can be used to customize the Cluster through
	// patches. They must comply to the corresponding
	// VariableClasses defined in the ClusterClass.
	// +optional
	variables?: [...#ClusterVariable] @go(Variables,[]ClusterVariable)
}

// ControlPlaneTopology specifies the parameters for the control plane nodes in the cluster.
#ControlPlaneTopology: {
	// Metadata is the metadata applied to the ControlPlane and the Machines of the ControlPlane
	// if the ControlPlaneTemplate referenced by the ClusterClass is machine based. If not, it
	// is applied only to the ControlPlane.
	// At runtime this metadata is merged with the corresponding metadata from the ClusterClass.
	// +optional
	metadata?: #ObjectMeta @go(Metadata)

	// Replicas is the number of control plane nodes.
	// If the value is nil, the ControlPlane object is created without the number of Replicas
	// and it's assumed that the control plane controller does not implement support for this field.
	// When specified against a control plane provider that lacks support for this field, this value will be ignored.
	// +optional
	replicas?: null | int32 @go(Replicas,*int32)

	// MachineHealthCheck allows to enable, disable and override
	// the MachineHealthCheck configuration in the ClusterClass for this control plane.
	// +optional
	machineHealthCheck?: null | #MachineHealthCheckTopology @go(MachineHealthCheck,*MachineHealthCheckTopology)

	// NodeDrainTimeout is the total amount of time that the controller will spend on draining a node.
	// The default value is 0, meaning that the node can be drained without any time limitations.
	// NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
	// +optional
	nodeDrainTimeout?: null | metav1.#Duration @go(NodeDrainTimeout,*metav1.Duration)

	// NodeVolumeDetachTimeout is the total amount of time that the controller will spend on waiting for all volumes
	// to be detached. The default value is 0, meaning that the volumes can be detached without any time limitations.
	// +optional
	nodeVolumeDetachTimeout?: null | metav1.#Duration @go(NodeVolumeDetachTimeout,*metav1.Duration)

	// NodeDeletionTimeout defines how long the controller will attempt to delete the Node that the Machine
	// hosts after the Machine is marked for deletion. A duration of 0 will retry deletion indefinitely.
	// Defaults to 10 seconds.
	// +optional
	nodeDeletionTimeout?: null | metav1.#Duration @go(NodeDeletionTimeout,*metav1.Duration)
}

// WorkersTopology represents the different sets of worker nodes in the cluster.
#WorkersTopology: {
	// MachineDeployments is a list of machine deployments in the cluster.
	// +optional
	machineDeployments?: [...#MachineDeploymentTopology] @go(MachineDeployments,[]MachineDeploymentTopology)
}

// MachineDeploymentTopology specifies the different parameters for a set of worker nodes in the topology.
// This set of nodes is managed by a MachineDeployment object whose lifecycle is managed by the Cluster controller.
#MachineDeploymentTopology: {
	// Metadata is the metadata applied to the MachineDeployment and the machines of the MachineDeployment.
	// At runtime this metadata is merged with the corresponding metadata from the ClusterClass.
	// +optional
	metadata?: #ObjectMeta @go(Metadata)

	// Class is the name of the MachineDeploymentClass used to create the set of worker nodes.
	// This should match one of the deployment classes defined in the ClusterClass object
	// mentioned in the `Cluster.Spec.Class` field.
	class: string @go(Class)

	// Name is the unique identifier for this MachineDeploymentTopology.
	// The value is used with other unique identifiers to create a MachineDeployment's Name
	// (e.g. cluster's name, etc). In case the name is greater than the allowed maximum length,
	// the values are hashed together.
	name: string @go(Name)

	// FailureDomain is the failure domain the machines will be created in.
	// Must match a key in the FailureDomains map stored on the cluster object.
	// +optional
	failureDomain?: null | string @go(FailureDomain,*string)

	// Replicas is the number of worker nodes belonging to this set.
	// If the value is nil, the MachineDeployment is created without the number of Replicas (defaulting to 1)
	// and it's assumed that an external entity (like cluster autoscaler) is responsible for the management
	// of this value.
	// +optional
	replicas?: null | int32 @go(Replicas,*int32)

	// MachineHealthCheck allows to enable, disable and override
	// the MachineHealthCheck configuration in the ClusterClass for this MachineDeployment.
	// +optional
	machineHealthCheck?: null | #MachineHealthCheckTopology @go(MachineHealthCheck,*MachineHealthCheckTopology)

	// NodeDrainTimeout is the total amount of time that the controller will spend on draining a node.
	// The default value is 0, meaning that the node can be drained without any time limitations.
	// NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
	// +optional
	nodeDrainTimeout?: null | metav1.#Duration @go(NodeDrainTimeout,*metav1.Duration)

	// NodeVolumeDetachTimeout is the total amount of time that the controller will spend on waiting for all volumes
	// to be detached. The default value is 0, meaning that the volumes can be detached without any time limitations.
	// +optional
	nodeVolumeDetachTimeout?: null | metav1.#Duration @go(NodeVolumeDetachTimeout,*metav1.Duration)

	// NodeDeletionTimeout defines how long the controller will attempt to delete the Node that the Machine
	// hosts after the Machine is marked for deletion. A duration of 0 will retry deletion indefinitely.
	// Defaults to 10 seconds.
	// +optional
	nodeDeletionTimeout?: null | metav1.#Duration @go(NodeDeletionTimeout,*metav1.Duration)

	// Minimum number of seconds for which a newly created machine should
	// be ready.
	// Defaults to 0 (machine will be considered available as soon as it
	// is ready)
	// +optional
	minReadySeconds?: null | int32 @go(MinReadySeconds,*int32)

	// The deployment strategy to use to replace existing machines with
	// new ones.
	// +optional
	strategy?: null | #MachineDeploymentStrategy @go(Strategy,*MachineDeploymentStrategy)

	// Variables can be used to customize the MachineDeployment through patches.
	// +optional
	variables?: null | #MachineDeploymentVariables @go(Variables,*MachineDeploymentVariables)
}

// MachineHealthCheckTopology defines a MachineHealthCheck for a group of machines.
#MachineHealthCheckTopology: {
	// Enable controls if a MachineHealthCheck should be created for the target machines.
	//
	// If false: No MachineHealthCheck will be created.
	//
	// If not set(default): A MachineHealthCheck will be created if it is defined here or
	//  in the associated ClusterClass. If no MachineHealthCheck is defined then none will be created.
	//
	// If true: A MachineHealthCheck is guaranteed to be created. Cluster validation will
	// block if `enable` is true and no MachineHealthCheck definition is available.
	// +optional
	enable?: null | bool @go(Enable,*bool)

	#MachineHealthCheckClass
}

// ClusterVariable can be used to customize the Cluster through patches. Each ClusterVariable is associated with a
// Variable definition in the ClusterClass `status` variables.
#ClusterVariable: {
	// Name of the variable.
	name: string @go(Name)

	// DefinitionFrom specifies where the definition of this Variable is from. DefinitionFrom is `inline` when the
	// definition is from the ClusterClass `.spec.variables` or the name of a patch defined in the ClusterClass
	// `.spec.patches` where the patch is external and provides external variables.
	// This field is mandatory if the variable has `DefinitionsConflict: true` in ClusterClass `status.variables[]`
	// +optional
	definitionFrom?: string @go(DefinitionFrom)

	// Value of the variable.
	// Note: the value will be validated against the schema of the corresponding ClusterClassVariable
	// from the ClusterClass.
	// Note: We have to use apiextensionsv1.JSON instead of a custom JSON type, because controller-tools has a
	// hard-coded schema for apiextensionsv1.JSON which cannot be produced by another type via controller-tools,
	// i.e. it is not possible to have no type field.
	// Ref: https://github.com/kubernetes-sigs/controller-tools/blob/d0e03a142d0ecdd5491593e941ee1d6b5d91dba6/pkg/crd/known_types.go#L106-L111
	value: apiextensionsv1.#JSON @go(Value)
}

// MachineDeploymentVariables can be used to provide variables for a specific MachineDeployment.
#MachineDeploymentVariables: {
	// Overrides can be used to override Cluster level variables.
	// +optional
	overrides?: [...#ClusterVariable] @go(Overrides,[]ClusterVariable)
}

// ClusterNetwork specifies the different networking
// parameters for a cluster.
#ClusterNetwork: {
	// APIServerPort specifies the port the API Server should bind to.
	// Defaults to 6443.
	// +optional
	apiServerPort?: null | int32 @go(APIServerPort,*int32)

	// The network ranges from which service VIPs are allocated.
	// +optional
	services?: null | #NetworkRanges @go(Services,*NetworkRanges)

	// The network ranges from which Pod networks are allocated.
	// +optional
	pods?: null | #NetworkRanges @go(Pods,*NetworkRanges)

	// Domain name for services.
	// +optional
	serviceDomain?: string @go(ServiceDomain)
}

// NetworkRanges represents ranges of network addresses.
#NetworkRanges: {
	cidrBlocks: [...string] @go(CIDRBlocks,[]string)
}

// ClusterStatus defines the observed state of Cluster.
#ClusterStatus: {
	// FailureDomains is a slice of failure domain objects synced from the infrastructure provider.
	// +optional
	failureDomains?: #FailureDomains @go(FailureDomains)

	// FailureReason indicates that there is a fatal problem reconciling the
	// state, and will be set to a token value suitable for
	// programmatic interpretation.
	// +optional
	failureReason?: null | capierrors.#ClusterStatusError @go(FailureReason,*capierrors.ClusterStatusError)

	// FailureMessage indicates that there is a fatal problem reconciling the
	// state, and will be set to a descriptive error message.
	// +optional
	failureMessage?: null | string @go(FailureMessage,*string)

	// Phase represents the current phase of cluster actuation.
	// E.g. Pending, Running, Terminating, Failed etc.
	// +optional
	phase?: string @go(Phase)

	// InfrastructureReady is the state of the infrastructure provider.
	// +optional
	infrastructureReady: bool @go(InfrastructureReady)

	// ControlPlaneReady defines if the control plane is ready.
	// +optional
	controlPlaneReady: bool @go(ControlPlaneReady)

	// Conditions defines current service state of the cluster.
	// +optional
	conditions?: #Conditions @go(Conditions)

	// ObservedGeneration is the latest generation observed by the controller.
	// +optional
	observedGeneration?: int64 @go(ObservedGeneration)
}

// APIEndpoint represents a reachable Kubernetes API endpoint.
#APIEndpoint: {
	// The hostname on which the API server is serving.
	host: string @go(Host)

	// The port on which the API server is serving.
	port: int32 @go(Port)
}

// Cluster is the Schema for the clusters API.
#Cluster: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)
	spec?:     #ClusterSpec       @go(Spec)
	status?:   #ClusterStatus     @go(Status)
}

// ClusterIPFamily defines the types of supported IP families.
#ClusterIPFamily: int // #enumClusterIPFamily

#enumClusterIPFamily:
	#InvalidIPFamily |
	#IPv4IPFamily |
	#IPv6IPFamily |
	#DualStackIPFamily

#values_ClusterIPFamily: {
	InvalidIPFamily:   #InvalidIPFamily
	IPv4IPFamily:      #IPv4IPFamily
	IPv6IPFamily:      #IPv6IPFamily
	DualStackIPFamily: #DualStackIPFamily
}

#InvalidIPFamily:   #ClusterIPFamily & 0
#IPv4IPFamily:      #ClusterIPFamily & 1
#IPv6IPFamily:      #ClusterIPFamily & 2
#DualStackIPFamily: #ClusterIPFamily & 3

// ClusterList contains a list of Cluster.
#ClusterList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#Cluster] @go(Items,[]Cluster)
}

// FailureDomains is a slice of FailureDomains.
#FailureDomains: {[string]: #FailureDomainSpec}

// FailureDomainSpec is the Schema for Cluster API failure domains.
// It allows controllers to understand how many failure domains a cluster can optionally span across.
#FailureDomainSpec: {
	// ControlPlane determines if this failure domain is suitable for use by control plane machines.
	// +optional
	controlPlane?: bool @go(ControlPlane)

	// Attributes is a free form map of attributes an infrastructure provider might use or require.
	// +optional
	attributes?: {[string]: string} @go(Attributes,map[string]string)
}
