// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go sigs.k8s.io/cluster-api/api/v1beta1

package v1beta1

import (
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	capierrors "sigs.k8s.io/cluster-api/errors"
)

// MachineFinalizer is set on PrepareForCreate callback.
#MachineFinalizer: "machine.cluster.x-k8s.io"

// MachineControlPlaneLabel is the label set on machines or related objects that are part of a control plane.
#MachineControlPlaneLabel: "cluster.x-k8s.io/control-plane"

// ExcludeNodeDrainingAnnotation annotation explicitly skips node draining if set.
#ExcludeNodeDrainingAnnotation: "machine.cluster.x-k8s.io/exclude-node-draining"

// ExcludeWaitForNodeVolumeDetachAnnotation annotation explicitly skips the waiting for node volume detaching if set.
#ExcludeWaitForNodeVolumeDetachAnnotation: "machine.cluster.x-k8s.io/exclude-wait-for-node-volume-detach"

// MachineSetNameLabel is the label set on machines if they're controlled by MachineSet.
// Note: The value of this label may be a hash if the MachineSet name is longer than 63 characters.
#MachineSetNameLabel: "cluster.x-k8s.io/set-name"

// MachineDeploymentNameLabel is the label set on machines if they're controlled by MachineDeployment.
#MachineDeploymentNameLabel: "cluster.x-k8s.io/deployment-name"

// MachinePoolNameLabel is the label indicating the name of the MachinePool a Machine is controlled by.
// Note: The value of this label may be a hash if the MachinePool name is longer than 63 characters.
#MachinePoolNameLabel: "cluster.x-k8s.io/pool-name"

// MachineControlPlaneNameLabel is the label set on machines if they're controlled by a ControlPlane.
// Note: The value of this label may be a hash if the control plane name is longer than 63 characters.
#MachineControlPlaneNameLabel: "cluster.x-k8s.io/control-plane-name"

// PreDrainDeleteHookAnnotationPrefix annotation specifies the prefix we
// search each annotation for during the pre-drain.delete lifecycle hook
// to pause reconciliation of deletion. These hooks will prevent removal of
// draining the associated node until all are removed.
#PreDrainDeleteHookAnnotationPrefix: "pre-drain.delete.hook.machine.cluster.x-k8s.io"

// PreTerminateDeleteHookAnnotationPrefix annotation specifies the prefix we
// search each annotation for during the pre-terminate.delete lifecycle hook
// to pause reconciliation of deletion. These hooks will prevent removal of
// an instance from an infrastructure provider until all are removed.
#PreTerminateDeleteHookAnnotationPrefix: "pre-terminate.delete.hook.machine.cluster.x-k8s.io"

// MachineCertificatesExpiryDateAnnotation annotation specifies the expiry date of the machine certificates in RFC3339 format.
// This annotation can be used on control plane machines to trigger rollout before certificates expire.
// This annotation can be set on BootstrapConfig or Machine objects. The value set on the Machine object takes precedence.
// This annotation can only be used on Control Plane Machines.
#MachineCertificatesExpiryDateAnnotation: "machine.cluster.x-k8s.io/certificates-expiry"

// NodeRoleLabelPrefix is one of the CAPI managed Node label prefixes.
#NodeRoleLabelPrefix: "node-role.kubernetes.io"

// NodeRestrictionLabelDomain is one of the CAPI managed Node label domains.
#NodeRestrictionLabelDomain: "node-restriction.kubernetes.io"

// ManagedNodeLabelDomain is one of the CAPI managed Node label domains.
#ManagedNodeLabelDomain: "node.cluster.x-k8s.io"

// MachineSpec defines the desired state of Machine.
#MachineSpec: {
	// ClusterName is the name of the Cluster this object belongs to.
	// +kubebuilder:validation:MinLength=1
	clusterName: string @go(ClusterName)

	// Bootstrap is a reference to a local struct which encapsulates
	// fields to configure the Machineâ€™s bootstrapping mechanism.
	bootstrap: #Bootstrap @go(Bootstrap)

	// InfrastructureRef is a required reference to a custom resource
	// offered by an infrastructure provider.
	infrastructureRef: corev1.#ObjectReference @go(InfrastructureRef)

	// Version defines the desired Kubernetes version.
	// This field is meant to be optionally used by bootstrap providers.
	// +optional
	version?: null | string @go(Version,*string)

	// ProviderID is the identification ID of the machine provided by the provider.
	// This field must match the provider ID as seen on the node object corresponding to this machine.
	// This field is required by higher level consumers of cluster-api. Example use case is cluster autoscaler
	// with cluster-api as provider. Clean-up logic in the autoscaler compares machines to nodes to find out
	// machines at provider which could not get registered as Kubernetes nodes. With cluster-api as a
	// generic out-of-tree provider for autoscaler, this field is required by autoscaler to be
	// able to have a provider view of the list of machines. Another list of nodes is queried from the k8s apiserver
	// and then a comparison is done to find out unregistered machines and are marked for delete.
	// This field will be set by the actuators and consumed by higher level entities like autoscaler that will
	// be interfacing with cluster-api as generic provider.
	// +optional
	providerID?: null | string @go(ProviderID,*string)

	// FailureDomain is the failure domain the machine will be created in.
	// Must match a key in the FailureDomains map stored on the cluster object.
	// +optional
	failureDomain?: null | string @go(FailureDomain,*string)

	// NodeDrainTimeout is the total amount of time that the controller will spend on draining a node.
	// The default value is 0, meaning that the node can be drained without any time limitations.
	// NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
	// +optional
	nodeDrainTimeout?: null | metav1.#Duration @go(NodeDrainTimeout,*metav1.Duration)

	// NodeVolumeDetachTimeout is the total amount of time that the controller will spend on waiting for all volumes
	// to be detached. The default value is 0, meaning that the volumes can be detached without any time limitations.
	// +optional
	nodeVolumeDetachTimeout?: null | metav1.#Duration @go(NodeVolumeDetachTimeout,*metav1.Duration)

	// NodeDeletionTimeout defines how long the controller will attempt to delete the Node that the Machine
	// hosts after the Machine is marked for deletion. A duration of 0 will retry deletion indefinitely.
	// Defaults to 10 seconds.
	// +optional
	nodeDeletionTimeout?: null | metav1.#Duration @go(NodeDeletionTimeout,*metav1.Duration)
}

// MachineStatus defines the observed state of Machine.
#MachineStatus: {
	// NodeRef will point to the corresponding Node if it exists.
	// +optional
	nodeRef?: null | corev1.#ObjectReference @go(NodeRef,*corev1.ObjectReference)

	// NodeInfo is a set of ids/uuids to uniquely identify the node.
	// More info: https://kubernetes.io/docs/concepts/nodes/node/#info
	// +optional
	nodeInfo?: null | corev1.#NodeSystemInfo @go(NodeInfo,*corev1.NodeSystemInfo)

	// LastUpdated identifies when the phase of the Machine last transitioned.
	// +optional
	lastUpdated?: null | metav1.#Time @go(LastUpdated,*metav1.Time)

	// FailureReason will be set in the event that there is a terminal problem
	// reconciling the Machine and will contain a succinct value suitable
	// for machine interpretation.
	//
	// This field should not be set for transitive errors that a controller
	// faces that are expected to be fixed automatically over
	// time (like service outages), but instead indicate that something is
	// fundamentally wrong with the Machine's spec or the configuration of
	// the controller, and that manual intervention is required. Examples
	// of terminal errors would be invalid combinations of settings in the
	// spec, values that are unsupported by the controller, or the
	// responsible controller itself being critically misconfigured.
	//
	// Any transient errors that occur during the reconciliation of Machines
	// can be added as events to the Machine object and/or logged in the
	// controller's output.
	// +optional
	failureReason?: null | capierrors.#MachineStatusError @go(FailureReason,*capierrors.MachineStatusError)

	// FailureMessage will be set in the event that there is a terminal problem
	// reconciling the Machine and will contain a more verbose string suitable
	// for logging and human consumption.
	//
	// This field should not be set for transitive errors that a controller
	// faces that are expected to be fixed automatically over
	// time (like service outages), but instead indicate that something is
	// fundamentally wrong with the Machine's spec or the configuration of
	// the controller, and that manual intervention is required. Examples
	// of terminal errors would be invalid combinations of settings in the
	// spec, values that are unsupported by the controller, or the
	// responsible controller itself being critically misconfigured.
	//
	// Any transient errors that occur during the reconciliation of Machines
	// can be added as events to the Machine object and/or logged in the
	// controller's output.
	// +optional
	failureMessage?: null | string @go(FailureMessage,*string)

	// Addresses is a list of addresses assigned to the machine.
	// This field is copied from the infrastructure provider reference.
	// +optional
	addresses?: #MachineAddresses @go(Addresses)

	// Phase represents the current phase of machine actuation.
	// E.g. Pending, Running, Terminating, Failed etc.
	// +optional
	phase?: string @go(Phase)

	// CertificatesExpiryDate is the expiry date of the machine certificates.
	// This value is only set for control plane machines.
	// +optional
	certificatesExpiryDate?: null | metav1.#Time @go(CertificatesExpiryDate,*metav1.Time)

	// BootstrapReady is the state of the bootstrap provider.
	// +optional
	bootstrapReady: bool @go(BootstrapReady)

	// InfrastructureReady is the state of the infrastructure provider.
	// +optional
	infrastructureReady: bool @go(InfrastructureReady)

	// ObservedGeneration is the latest generation observed by the controller.
	// +optional
	observedGeneration?: int64 @go(ObservedGeneration)

	// Conditions defines current service state of the Machine.
	// +optional
	conditions?: #Conditions @go(Conditions)
}

// Bootstrap encapsulates fields to configure the Machineâ€™s bootstrapping mechanism.
#Bootstrap: {
	// ConfigRef is a reference to a bootstrap provider-specific resource
	// that holds configuration details. The reference is optional to
	// allow users/operators to specify Bootstrap.DataSecretName without
	// the need of a controller.
	// +optional
	configRef?: null | corev1.#ObjectReference @go(ConfigRef,*corev1.ObjectReference)

	// DataSecretName is the name of the secret that stores the bootstrap data script.
	// If nil, the Machine should remain in the Pending state.
	// +optional
	dataSecretName?: null | string @go(DataSecretName,*string)
}

// Machine is the Schema for the machines API.
#Machine: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)
	spec?:     #MachineSpec       @go(Spec)
	status?:   #MachineStatus     @go(Status)
}

// MachineList contains a list of Machine.
#MachineList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#Machine] @go(Items,[]Machine)
}
