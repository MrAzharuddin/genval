// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go sigs.k8s.io/cluster-api/api/v1alpha4

package v1alpha4

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	corev1 "k8s.io/api/core/v1"
)

// ClusterClass is a template which can be used to create managed topologies.
//
// Deprecated: This type will be removed in one of the next releases.
#ClusterClass: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)
	spec?:     #ClusterClassSpec  @go(Spec)
}

// ClusterClassSpec describes the desired state of the ClusterClass.
#ClusterClassSpec: {
	// Infrastructure is a reference to a provider-specific template that holds
	// the details for provisioning infrastructure specific cluster
	// for the underlying provider.
	// The underlying provider is responsible for the implementation
	// of the template to an infrastructure cluster.
	infrastructure?: #LocalObjectTemplate @go(Infrastructure)

	// ControlPlane is a reference to a local struct that holds the details
	// for provisioning the Control Plane for the Cluster.
	controlPlane?: #ControlPlaneClass @go(ControlPlane)

	// Workers describes the worker nodes for the cluster.
	// It is a collection of node types which can be used to create
	// the worker nodes of the cluster.
	// +optional
	workers?: #WorkersClass @go(Workers)
}

// ControlPlaneClass defines the class for the control plane.
#ControlPlaneClass: {
	// Metadata is the metadata applied to the machines of the ControlPlane.
	// At runtime this metadata is merged with the corresponding metadata from the topology.
	//
	// This field is supported if and only if the control plane provider template
	// referenced is Machine based.
	metadata?: #ObjectMeta @go(Metadata)

	#LocalObjectTemplate

	// MachineTemplate defines the metadata and infrastructure information
	// for control plane machines.
	//
	// This field is supported if and only if the control plane provider template
	// referenced above is Machine based and supports setting replicas.
	//
	// +optional
	machineInfrastructure?: null | #LocalObjectTemplate @go(MachineInfrastructure,*LocalObjectTemplate)
}

// WorkersClass is a collection of deployment classes.
#WorkersClass: {
	// MachineDeployments is a list of machine deployment classes that can be used to create
	// a set of worker nodes.
	machineDeployments?: [...#MachineDeploymentClass] @go(MachineDeployments,[]MachineDeploymentClass)
}

// MachineDeploymentClass serves as a template to define a set of worker nodes of the cluster
// provisioned using the `ClusterClass`.
#MachineDeploymentClass: {
	// Class denotes a type of worker node present in the cluster,
	// this name MUST be unique within a ClusterClass and can be referenced
	// in the Cluster to create a managed MachineDeployment.
	class: string @go(Class)

	// Template is a local struct containing a collection of templates for creation of
	// MachineDeployment objects representing a set of worker nodes.
	template: #MachineDeploymentClassTemplate @go(Template)
}

// MachineDeploymentClassTemplate defines how a MachineDeployment generated from a MachineDeploymentClass
// should look like.
#MachineDeploymentClassTemplate: {
	// Metadata is the metadata applied to the machines of the MachineDeployment.
	// At runtime this metadata is merged with the corresponding metadata from the topology.
	metadata?: #ObjectMeta @go(Metadata)

	// Bootstrap contains the bootstrap template reference to be used
	// for the creation of worker Machines.
	bootstrap: #LocalObjectTemplate @go(Bootstrap)

	// Infrastructure contains the infrastructure template reference to be used
	// for the creation of worker Machines.
	infrastructure: #LocalObjectTemplate @go(Infrastructure)
}

// LocalObjectTemplate defines a template for a topology Class.
#LocalObjectTemplate: {
	// Ref is a required reference to a custom resource
	// offered by a provider.
	ref?: null | corev1.#ObjectReference @go(Ref,*corev1.ObjectReference)
}

// ClusterClassList contains a list of Cluster.
//
// Deprecated: This type will be removed in one of the next releases.
#ClusterClassList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#ClusterClass] @go(Items,[]ClusterClass)
}
