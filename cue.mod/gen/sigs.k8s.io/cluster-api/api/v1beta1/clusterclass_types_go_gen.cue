// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go sigs.k8s.io/cluster-api/api/v1beta1

package v1beta1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/intstr"
	corev1 "k8s.io/api/core/v1"
	apiextensionsv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
)

#ClusterClassKind: "ClusterClass"

// ClusterClass is a template which can be used to create managed topologies.
#ClusterClass: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta  @go(ObjectMeta)
	spec?:     #ClusterClassSpec   @go(Spec)
	status?:   #ClusterClassStatus @go(Status)
}

// ClusterClassSpec describes the desired state of the ClusterClass.
#ClusterClassSpec: {
	// Infrastructure is a reference to a provider-specific template that holds
	// the details for provisioning infrastructure specific cluster
	// for the underlying provider.
	// The underlying provider is responsible for the implementation
	// of the template to an infrastructure cluster.
	// +optional
	infrastructure?: #LocalObjectTemplate @go(Infrastructure)

	// ControlPlane is a reference to a local struct that holds the details
	// for provisioning the Control Plane for the Cluster.
	// +optional
	controlPlane?: #ControlPlaneClass @go(ControlPlane)

	// Workers describes the worker nodes for the cluster.
	// It is a collection of node types which can be used to create
	// the worker nodes of the cluster.
	// +optional
	workers?: #WorkersClass @go(Workers)

	// Variables defines the variables which can be configured
	// in the Cluster topology and are then used in patches.
	// +optional
	variables?: [...#ClusterClassVariable] @go(Variables,[]ClusterClassVariable)

	// Patches defines the patches which are applied to customize
	// referenced templates of a ClusterClass.
	// Note: Patches will be applied in the order of the array.
	// +optional
	patches?: [...#ClusterClassPatch] @go(Patches,[]ClusterClassPatch)
}

// ControlPlaneClass defines the class for the control plane.
#ControlPlaneClass: {
	// Metadata is the metadata applied to the ControlPlane and the Machines of the ControlPlane
	// if the ControlPlaneTemplate referenced is machine based. If not, it is applied only to the
	// ControlPlane.
	// At runtime this metadata is merged with the corresponding metadata from the topology.
	//
	// This field is supported if and only if the control plane provider template
	// referenced is Machine based.
	// +optional
	metadata?: #ObjectMeta @go(Metadata)

	#LocalObjectTemplate

	// MachineInfrastructure defines the metadata and infrastructure information
	// for control plane machines.
	//
	// This field is supported if and only if the control plane provider template
	// referenced above is Machine based and supports setting replicas.
	//
	// +optional
	machineInfrastructure?: null | #LocalObjectTemplate @go(MachineInfrastructure,*LocalObjectTemplate)

	// MachineHealthCheck defines a MachineHealthCheck for this ControlPlaneClass.
	// This field is supported if and only if the ControlPlane provider template
	// referenced above is Machine based and supports setting replicas.
	// +optional
	machineHealthCheck?: null | #MachineHealthCheckClass @go(MachineHealthCheck,*MachineHealthCheckClass)

	// NamingStrategy allows changing the naming pattern used when creating the control plane provider object.
	// +optional
	namingStrategy?: null | #ControlPlaneClassNamingStrategy @go(NamingStrategy,*ControlPlaneClassNamingStrategy)

	// NodeDrainTimeout is the total amount of time that the controller will spend on draining a node.
	// The default value is 0, meaning that the node can be drained without any time limitations.
	// NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
	// NOTE: This value can be overridden while defining a Cluster.Topology.
	// +optional
	nodeDrainTimeout?: null | metav1.#Duration @go(NodeDrainTimeout,*metav1.Duration)

	// NodeVolumeDetachTimeout is the total amount of time that the controller will spend on waiting for all volumes
	// to be detached. The default value is 0, meaning that the volumes can be detached without any time limitations.
	// NOTE: This value can be overridden while defining a Cluster.Topology.
	// +optional
	nodeVolumeDetachTimeout?: null | metav1.#Duration @go(NodeVolumeDetachTimeout,*metav1.Duration)

	// NodeDeletionTimeout defines how long the controller will attempt to delete the Node that the Machine
	// hosts after the Machine is marked for deletion. A duration of 0 will retry deletion indefinitely.
	// Defaults to 10 seconds.
	// NOTE: This value can be overridden while defining a Cluster.Topology.
	// +optional
	nodeDeletionTimeout?: null | metav1.#Duration @go(NodeDeletionTimeout,*metav1.Duration)
}

// ControlPlaneClassNamingStrategy defines the naming strategy for control plane objects.
#ControlPlaneClassNamingStrategy: {
	// Template defines the template to use for generating the name of the ControlPlane object.
	// If not defined, it will fallback to `{{ .cluster.name }}-{{ .random }}`.
	// If the templated string exceeds 63 characters, it will be trimmed to 58 characters and will
	// get concatenated with a random suffix of length 5.
	// The templating mechanism provides the following arguments:
	// * `.cluster.name`: The name of the cluster object.
	// * `.random`: A random alphanumeric string, without vowels, of length 5.
	// +optional
	template?: null | string @go(Template,*string)
}

// WorkersClass is a collection of deployment classes.
#WorkersClass: {
	// MachineDeployments is a list of machine deployment classes that can be used to create
	// a set of worker nodes.
	// +optional
	machineDeployments?: [...#MachineDeploymentClass] @go(MachineDeployments,[]MachineDeploymentClass)
}

// MachineDeploymentClass serves as a template to define a set of worker nodes of the cluster
// provisioned using the `ClusterClass`.
#MachineDeploymentClass: {
	// Class denotes a type of worker node present in the cluster,
	// this name MUST be unique within a ClusterClass and can be referenced
	// in the Cluster to create a managed MachineDeployment.
	class: string @go(Class)

	// Template is a local struct containing a collection of templates for creation of
	// MachineDeployment objects representing a set of worker nodes.
	template: #MachineDeploymentClassTemplate @go(Template)

	// MachineHealthCheck defines a MachineHealthCheck for this MachineDeploymentClass.
	// +optional
	machineHealthCheck?: null | #MachineHealthCheckClass @go(MachineHealthCheck,*MachineHealthCheckClass)

	// FailureDomain is the failure domain the machines will be created in.
	// Must match a key in the FailureDomains map stored on the cluster object.
	// NOTE: This value can be overridden while defining a Cluster.Topology using this MachineDeploymentClass.
	// +optional
	failureDomain?: null | string @go(FailureDomain,*string)

	// NamingStrategy allows changing the naming pattern used when creating the MachineDeployment.
	// +optional
	namingStrategy?: null | #MachineDeploymentClassNamingStrategy @go(NamingStrategy,*MachineDeploymentClassNamingStrategy)

	// NodeDrainTimeout is the total amount of time that the controller will spend on draining a node.
	// The default value is 0, meaning that the node can be drained without any time limitations.
	// NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
	// NOTE: This value can be overridden while defining a Cluster.Topology using this MachineDeploymentClass.
	// +optional
	nodeDrainTimeout?: null | metav1.#Duration @go(NodeDrainTimeout,*metav1.Duration)

	// NodeVolumeDetachTimeout is the total amount of time that the controller will spend on waiting for all volumes
	// to be detached. The default value is 0, meaning that the volumes can be detached without any time limitations.
	// NOTE: This value can be overridden while defining a Cluster.Topology using this MachineDeploymentClass.
	// +optional
	nodeVolumeDetachTimeout?: null | metav1.#Duration @go(NodeVolumeDetachTimeout,*metav1.Duration)

	// NodeDeletionTimeout defines how long the controller will attempt to delete the Node that the Machine
	// hosts after the Machine is marked for deletion. A duration of 0 will retry deletion indefinitely.
	// Defaults to 10 seconds.
	// NOTE: This value can be overridden while defining a Cluster.Topology using this MachineDeploymentClass.
	// +optional
	nodeDeletionTimeout?: null | metav1.#Duration @go(NodeDeletionTimeout,*metav1.Duration)

	// Minimum number of seconds for which a newly created machine should
	// be ready.
	// Defaults to 0 (machine will be considered available as soon as it
	// is ready)
	// NOTE: This value can be overridden while defining a Cluster.Topology using this MachineDeploymentClass.
	minReadySeconds?: null | int32 @go(MinReadySeconds,*int32)

	// The deployment strategy to use to replace existing machines with
	// new ones.
	// NOTE: This value can be overridden while defining a Cluster.Topology using this MachineDeploymentClass.
	strategy?: null | #MachineDeploymentStrategy @go(Strategy,*MachineDeploymentStrategy)
}

// MachineDeploymentClassTemplate defines how a MachineDeployment generated from a MachineDeploymentClass
// should look like.
#MachineDeploymentClassTemplate: {
	// Metadata is the metadata applied to the MachineDeployment and the machines of the MachineDeployment.
	// At runtime this metadata is merged with the corresponding metadata from the topology.
	// +optional
	metadata?: #ObjectMeta @go(Metadata)

	// Bootstrap contains the bootstrap template reference to be used
	// for the creation of worker Machines.
	bootstrap: #LocalObjectTemplate @go(Bootstrap)

	// Infrastructure contains the infrastructure template reference to be used
	// for the creation of worker Machines.
	infrastructure: #LocalObjectTemplate @go(Infrastructure)
}

// MachineDeploymentClassNamingStrategy defines the naming strategy for machine deployment objects.
#MachineDeploymentClassNamingStrategy: {
	// Template defines the template to use for generating the name of the MachineDeployment object.
	// If not defined, it will fallback to `{{ .cluster.name }}-{{ .machineDeployment.topologyName }}-{{ .random }}`.
	// If the templated string exceeds 63 characters, it will be trimmed to 58 characters and will
	// get concatenated with a random suffix of length 5.
	// The templating mechanism provides the following arguments:
	// * `.cluster.name`: The name of the cluster object.
	// * `.random`: A random alphanumeric string, without vowels, of length 5.
	// * `.machineDeployment.topologyName`: The name of the MachineDeployment topology (Cluster.spec.topology.workers.machineDeployments[].name).
	// +optional
	template?: null | string @go(Template,*string)
}

// MachineHealthCheckClass defines a MachineHealthCheck for a group of Machines.
#MachineHealthCheckClass: {
	// UnhealthyConditions contains a list of the conditions that determine
	// whether a node is considered unhealthy. The conditions are combined in a
	// logical OR, i.e. if any of the conditions is met, the node is unhealthy.
	unhealthyConditions?: [...#UnhealthyCondition] @go(UnhealthyConditions,[]UnhealthyCondition)

	// Any further remediation is only allowed if at most "MaxUnhealthy" machines selected by
	// "selector" are not healthy.
	// +optional
	maxUnhealthy?: null | intstr.#IntOrString @go(MaxUnhealthy,*intstr.IntOrString)

	// Any further remediation is only allowed if the number of machines selected by "selector" as not healthy
	// is within the range of "UnhealthyRange". Takes precedence over MaxUnhealthy.
	// Eg. "[3-5]" - This means that remediation will be allowed only when:
	// (a) there are at least 3 unhealthy machines (and)
	// (b) there are at most 5 unhealthy machines
	// +optional
	// +kubebuilder:validation:Pattern=^\[[0-9]+-[0-9]+\]$
	unhealthyRange?: null | string @go(UnhealthyRange,*string)

	// Machines older than this duration without a node will be considered to have
	// failed and will be remediated.
	// If you wish to disable this feature, set the value explicitly to 0.
	// +optional
	nodeStartupTimeout?: null | metav1.#Duration @go(NodeStartupTimeout,*metav1.Duration)

	// RemediationTemplate is a reference to a remediation template
	// provided by an infrastructure provider.
	//
	// This field is completely optional, when filled, the MachineHealthCheck controller
	// creates a new object from the template referenced and hands off remediation of the machine to
	// a controller that lives outside of Cluster API.
	// +optional
	remediationTemplate?: null | corev1.#ObjectReference @go(RemediationTemplate,*corev1.ObjectReference)
}

// ClusterClassVariable defines a variable which can
// be configured in the Cluster topology and used in patches.
#ClusterClassVariable: {
	// Name of the variable.
	name: string @go(Name)

	// Required specifies if the variable is required.
	// Note: this applies to the variable as a whole and thus the
	// top-level object defined in the schema. If nested fields are
	// required, this will be specified inside the schema.
	required: bool @go(Required)

	// Schema defines the schema of the variable.
	schema: #VariableSchema @go(Schema)
}

// VariableSchema defines the schema of a variable.
#VariableSchema: {
	// OpenAPIV3Schema defines the schema of a variable via OpenAPI v3
	// schema. The schema is a subset of the schema used in
	// Kubernetes CRDs.
	openAPIV3Schema: #JSONSchemaProps @go(OpenAPIV3Schema)
}

// JSONSchemaProps is a JSON-Schema following Specification Draft 4 (http://json-schema.org/).
// This struct has been initially copied from apiextensionsv1.JSONSchemaProps, but all fields
// which are not supported in CAPI have been removed.
#JSONSchemaProps: {
	// Description is a human-readable description of this variable.
	description?: string @go(Description)

	// Example is an example for this variable.
	example?: null | apiextensionsv1.#JSON @go(Example,*apiextensionsv1.JSON)

	// Type is the type of the variable.
	// Valid values are: object, array, string, integer, number or boolean.
	type: string @go(Type)

	// Properties specifies fields of an object.
	// NOTE: Can only be set if type is object.
	// NOTE: Properties is mutually exclusive with AdditionalProperties.
	// NOTE: This field uses PreserveUnknownFields and Schemaless,
	// because recursive validation is not possible.
	// +optional
	// +kubebuilder:pruning:PreserveUnknownFields
	// +kubebuilder:validation:Schemaless
	properties?: {[string]: #JSONSchemaProps} @go(Properties,map[string]JSONSchemaProps)

	// AdditionalProperties specifies the schema of values in a map (keys are always strings).
	// NOTE: Can only be set if type is object.
	// NOTE: AdditionalProperties is mutually exclusive with Properties.
	// NOTE: This field uses PreserveUnknownFields and Schemaless,
	// because recursive validation is not possible.
	// +optional
	// +kubebuilder:pruning:PreserveUnknownFields
	// +kubebuilder:validation:Schemaless
	additionalProperties?: null | #JSONSchemaProps @go(AdditionalProperties,*JSONSchemaProps)

	// Required specifies which fields of an object are required.
	// NOTE: Can only be set if type is object.
	// +optional
	required?: [...string] @go(Required,[]string)

	// Items specifies fields of an array.
	// NOTE: Can only be set if type is array.
	// NOTE: This field uses PreserveUnknownFields and Schemaless,
	// because recursive validation is not possible.
	// +optional
	// +kubebuilder:pruning:PreserveUnknownFields
	// +kubebuilder:validation:Schemaless
	items?: null | #JSONSchemaProps @go(Items,*JSONSchemaProps)

	// MaxItems is the max length of an array variable.
	// NOTE: Can only be set if type is array.
	// +optional
	maxItems?: null | int64 @go(MaxItems,*int64)

	// MinItems is the min length of an array variable.
	// NOTE: Can only be set if type is array.
	// +optional
	minItems?: null | int64 @go(MinItems,*int64)

	// UniqueItems specifies if items in an array must be unique.
	// NOTE: Can only be set if type is array.
	// +optional
	uniqueItems?: bool @go(UniqueItems)

	// Format is an OpenAPI v3 format string. Unknown formats are ignored.
	// For a list of supported formats please see: (of the k8s.io/apiextensions-apiserver version we're currently using)
	// https://github.com/kubernetes/apiextensions-apiserver/blob/master/pkg/apiserver/validation/formats.go
	// NOTE: Can only be set if type is string.
	// +optional
	format?: string @go(Format)

	// MaxLength is the max length of a string variable.
	// NOTE: Can only be set if type is string.
	// +optional
	maxLength?: null | int64 @go(MaxLength,*int64)

	// MinLength is the min length of a string variable.
	// NOTE: Can only be set if type is string.
	// +optional
	minLength?: null | int64 @go(MinLength,*int64)

	// Pattern is the regex which a string variable must match.
	// NOTE: Can only be set if type is string.
	// +optional
	pattern?: string @go(Pattern)

	// Maximum is the maximum of an integer or number variable.
	// If ExclusiveMaximum is false, the variable is valid if it is lower than, or equal to, the value of Maximum.
	// If ExclusiveMaximum is true, the variable is valid if it is strictly lower than the value of Maximum.
	// NOTE: Can only be set if type is integer or number.
	// +optional
	maximum?: null | int64 @go(Maximum,*int64)

	// ExclusiveMaximum specifies if the Maximum is exclusive.
	// NOTE: Can only be set if type is integer or number.
	// +optional
	exclusiveMaximum?: bool @go(ExclusiveMaximum)

	// Minimum is the minimum of an integer or number variable.
	// If ExclusiveMinimum is false, the variable is valid if it is greater than, or equal to, the value of Minimum.
	// If ExclusiveMinimum is true, the variable is valid if it is strictly greater than the value of Minimum.
	// NOTE: Can only be set if type is integer or number.
	// +optional
	minimum?: null | int64 @go(Minimum,*int64)

	// ExclusiveMinimum specifies if the Minimum is exclusive.
	// NOTE: Can only be set if type is integer or number.
	// +optional
	exclusiveMinimum?: bool @go(ExclusiveMinimum)

	// XPreserveUnknownFields allows setting fields in a variable object
	// which are not defined in the variable schema. This affects fields recursively,
	// except if nested properties or additionalProperties are specified in the schema.
	// +optional
	"x-kubernetes-preserve-unknown-fields"?: bool @go(XPreserveUnknownFields)

	// Enum is the list of valid values of the variable.
	// NOTE: Can be set for all types.
	// +optional
	enum?: [...apiextensionsv1.#JSON] @go(Enum,[]apiextensionsv1.JSON)

	// Default is the default value of the variable.
	// NOTE: Can be set for all types.
	// +optional
	default?: null | apiextensionsv1.#JSON @go(Default,*apiextensionsv1.JSON)
}

// ClusterClassPatch defines a patch which is applied to customize the referenced templates.
#ClusterClassPatch: {
	// Name of the patch.
	name: string @go(Name)

	// Description is a human-readable description of this patch.
	description?: string @go(Description)

	// EnabledIf is a Go template to be used to calculate if a patch should be enabled.
	// It can reference variables defined in .spec.variables and builtin variables.
	// The patch will be enabled if the template evaluates to `true`, otherwise it will
	// be disabled.
	// If EnabledIf is not set, the patch will be enabled per default.
	// +optional
	enabledIf?: null | string @go(EnabledIf,*string)

	// Definitions define inline patches.
	// Note: Patches will be applied in the order of the array.
	// Note: Exactly one of Definitions or External must be set.
	// +optional
	definitions?: [...#PatchDefinition] @go(Definitions,[]PatchDefinition)

	// External defines an external patch.
	// Note: Exactly one of Definitions or External must be set.
	// +optional
	external?: null | #ExternalPatchDefinition @go(External,*ExternalPatchDefinition)
}

// PatchDefinition defines a patch which is applied to customize the referenced templates.
#PatchDefinition: {
	// Selector defines on which templates the patch should be applied.
	selector: #PatchSelector @go(Selector)

	// JSONPatches defines the patches which should be applied on the templates
	// matching the selector.
	// Note: Patches will be applied in the order of the array.
	jsonPatches: [...#JSONPatch] @go(JSONPatches,[]JSONPatch)
}

// PatchSelector defines on which templates the patch should be applied.
// Note: Matching on APIVersion and Kind is mandatory, to enforce that the patches are
// written for the correct version. The version of the references in the ClusterClass may
// be automatically updated during reconciliation if there is a newer version for the same contract.
// Note: The results of selection based on the individual fields are ANDed.
#PatchSelector: {
	// APIVersion filters templates by apiVersion.
	apiVersion: string @go(APIVersion)

	// Kind filters templates by kind.
	kind: string @go(Kind)

	// MatchResources selects templates based on where they are referenced.
	matchResources: #PatchSelectorMatch @go(MatchResources)
}

// PatchSelectorMatch selects templates based on where they are referenced.
// Note: The selector must match at least one template.
// Note: The results of selection based on the individual fields are ORed.
#PatchSelectorMatch: {
	// ControlPlane selects templates referenced in .spec.ControlPlane.
	// Note: this will match the controlPlane and also the controlPlane
	// machineInfrastructure (depending on the kind and apiVersion).
	// +optional
	controlPlane?: bool @go(ControlPlane)

	// InfrastructureCluster selects templates referenced in .spec.infrastructure.
	// +optional
	infrastructureCluster?: bool @go(InfrastructureCluster)

	// MachineDeploymentClass selects templates referenced in specific MachineDeploymentClasses in
	// .spec.workers.machineDeployments.
	// +optional
	machineDeploymentClass?: null | #PatchSelectorMatchMachineDeploymentClass @go(MachineDeploymentClass,*PatchSelectorMatchMachineDeploymentClass)
}

// PatchSelectorMatchMachineDeploymentClass selects templates referenced
// in specific MachineDeploymentClasses in .spec.workers.machineDeployments.
#PatchSelectorMatchMachineDeploymentClass: {
	// Names selects templates by class names.
	// +optional
	names?: [...string] @go(Names,[]string)
}

// JSONPatch defines a JSON patch.
#JSONPatch: {
	// Op defines the operation of the patch.
	// Note: Only `add`, `replace` and `remove` are supported.
	op: string @go(Op)

	// Path defines the path of the patch.
	// Note: Only the spec of a template can be patched, thus the path has to start with /spec/.
	// Note: For now the only allowed array modifications are `append` and `prepend`, i.e.:
	// * for op: `add`: only index 0 (prepend) and - (append) are allowed
	// * for op: `replace` or `remove`: no indexes are allowed
	path: string @go(Path)

	// Value defines the value of the patch.
	// Note: Either Value or ValueFrom is required for add and replace
	// operations. Only one of them is allowed to be set at the same time.
	// Note: We have to use apiextensionsv1.JSON instead of our JSON type,
	// because controller-tools has a hard-coded schema for apiextensionsv1.JSON
	// which cannot be produced by another type (unset type field).
	// Ref: https://github.com/kubernetes-sigs/controller-tools/blob/d0e03a142d0ecdd5491593e941ee1d6b5d91dba6/pkg/crd/known_types.go#L106-L111
	// +optional
	value?: null | apiextensionsv1.#JSON @go(Value,*apiextensionsv1.JSON)

	// ValueFrom defines the value of the patch.
	// Note: Either Value or ValueFrom is required for add and replace
	// operations. Only one of them is allowed to be set at the same time.
	// +optional
	valueFrom?: null | #JSONPatchValue @go(ValueFrom,*JSONPatchValue)
}

// JSONPatchValue defines the value of a patch.
// Note: Only one of the fields is allowed to be set at the same time.
#JSONPatchValue: {
	// Variable is the variable to be used as value.
	// Variable can be one of the variables defined in .spec.variables or a builtin variable.
	// +optional
	variable?: null | string @go(Variable,*string)

	// Template is the Go template to be used to calculate the value.
	// A template can reference variables defined in .spec.variables and builtin variables.
	// Note: The template must evaluate to a valid YAML or JSON value.
	// +optional
	template?: null | string @go(Template,*string)
}

// ExternalPatchDefinition defines an external patch.
// Note: At least one of GenerateExtension or ValidateExtension must be set.
#ExternalPatchDefinition: {
	// GenerateExtension references an extension which is called to generate patches.
	// +optional
	generateExtension?: null | string @go(GenerateExtension,*string)

	// ValidateExtension references an extension which is called to validate the topology.
	// +optional
	validateExtension?: null | string @go(ValidateExtension,*string)

	// DiscoverVariablesExtension references an extension which is called to discover variables.
	// +optional
	discoverVariablesExtension?: null | string @go(DiscoverVariablesExtension,*string)

	// Settings defines key value pairs to be passed to the extensions.
	// Values defined here take precedence over the values defined in the
	// corresponding ExtensionConfig.
	// +optional
	settings?: {[string]: string} @go(Settings,map[string]string)
}

// LocalObjectTemplate defines a template for a topology Class.
#LocalObjectTemplate: {
	// Ref is a required reference to a custom resource
	// offered by a provider.
	ref?: null | corev1.#ObjectReference @go(Ref,*corev1.ObjectReference)
}

// ClusterClassStatus defines the observed state of the ClusterClass.
#ClusterClassStatus: {
	// Variables is a list of ClusterClassStatusVariable that are defined for the ClusterClass.
	// +optional
	variables?: [...#ClusterClassStatusVariable] @go(Variables,[]ClusterClassStatusVariable)

	// Conditions defines current observed state of the ClusterClass.
	// +optional
	conditions?: #Conditions @go(Conditions)

	// ObservedGeneration is the latest generation observed by the controller.
	// +optional
	observedGeneration?: int64 @go(ObservedGeneration)
}

// ClusterClassStatusVariable defines a variable which appears in the status of a ClusterClass.
#ClusterClassStatusVariable: {
	// Name is the name of the variable.
	name: string @go(Name)

	// DefinitionsConflict specifies whether or not there are conflicting definitions for a single variable name.
	// +optional
	definitionsConflict: bool @go(DefinitionsConflict)

	// Definitions is a list of definitions for a variable.
	definitions: [...#ClusterClassStatusVariableDefinition] @go(Definitions,[]ClusterClassStatusVariableDefinition)
}

// ClusterClassStatusVariableDefinition defines a variable which appears in the status of a ClusterClass.
#ClusterClassStatusVariableDefinition: {
	// From specifies the origin of the variable definition.
	// This will be `inline` for variables defined in the ClusterClass or the name of a patch defined in the ClusterClass
	// for variables discovered from a DiscoverVariables runtime extensions.
	from: string @go(From)

	// Required specifies if the variable is required.
	// Note: this applies to the variable as a whole and thus the
	// top-level object defined in the schema. If nested fields are
	// required, this will be specified inside the schema.
	required: bool @go(Required)

	// Schema defines the schema of the variable.
	schema: #VariableSchema @go(Schema)
}

// ClusterClassList contains a list of Cluster.
#ClusterClassList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#ClusterClass] @go(Items,[]ClusterClass)
}
