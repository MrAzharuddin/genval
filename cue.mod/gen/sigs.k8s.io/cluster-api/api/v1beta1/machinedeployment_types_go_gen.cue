// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go sigs.k8s.io/cluster-api/api/v1beta1

package v1beta1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/intstr"
)

// MachineDeploymentTopologyFinalizer is the finalizer used by the topology MachineDeployment controller to
// clean up referenced template resources if necessary when a MachineDeployment is being deleted.
#MachineDeploymentTopologyFinalizer: "machinedeployment.topology.cluster.x-k8s.io"

// MachineDeploymentStrategyType defines the type of MachineDeployment rollout strategies.
#MachineDeploymentStrategyType: string // #enumMachineDeploymentStrategyType

#enumMachineDeploymentStrategyType:
	#RollingUpdateMachineDeploymentStrategyType |
	#OnDeleteMachineDeploymentStrategyType

// RollingUpdateMachineDeploymentStrategyType replaces the old MachineSet by new one using rolling update
// i.e. gradually scale down the old MachineSet and scale up the new one.
#RollingUpdateMachineDeploymentStrategyType: #MachineDeploymentStrategyType & "RollingUpdate"

// OnDeleteMachineDeploymentStrategyType replaces old MachineSets when the deletion of the associated machines are completed.
#OnDeleteMachineDeploymentStrategyType: #MachineDeploymentStrategyType & "OnDelete"

// RevisionAnnotation is the revision annotation of a machine deployment's machine sets which records its rollout sequence.
#RevisionAnnotation: "machinedeployment.clusters.x-k8s.io/revision"

// RevisionHistoryAnnotation maintains the history of all old revisions that a machine set has served for a machine deployment.
#RevisionHistoryAnnotation: "machinedeployment.clusters.x-k8s.io/revision-history"

// DesiredReplicasAnnotation is the desired replicas for a machine deployment recorded as an annotation
// in its machine sets. Helps in separating scaling events from the rollout process and for
// determining if the new machine set for a deployment is really saturated.
#DesiredReplicasAnnotation: "machinedeployment.clusters.x-k8s.io/desired-replicas"

// MaxReplicasAnnotation is the maximum replicas a deployment can have at a given point, which
// is machinedeployment.spec.replicas + maxSurge. Used by the underlying machine sets to estimate their
// proportions in case the deployment has surge replicas.
#MaxReplicasAnnotation: "machinedeployment.clusters.x-k8s.io/max-replicas"

// MachineDeploymentUniqueLabel is used to uniquely identify the Machines of a MachineSet.
// The MachineDeployment controller will set this label on a MachineSet when it is created.
// The label is also applied to the Machines of the MachineSet and used in the MachineSet selector.
// Note: For the lifetime of the MachineSet the label's value has to stay the same, otherwise the
// MachineSet selector would no longer match its Machines.
// Note: In previous Cluster API versions (< v1.4.0), the label value was the hash of the full machine template.
// With the introduction of in-place mutation the machine template of the MachineSet can change.
// Because of that it is impossible that the label's value to always be the hash of the full machine template.
// (Because the hash changes when the machine template changes).
// As a result, we use the hash of the machine template while ignoring all in-place mutable fields, i.e. the
// machine template with only fields that could trigger a rollout for the machine-template-hash, making it
// independent of the changes to any in-place mutable fields.
// A random string is appended at the end of the label value (label value format is "<hash>-<random string>"))
// to distinguish duplicate MachineSets that have the exact same spec but were created as a result of rolloutAfter.
#MachineDeploymentUniqueLabel: "machine-template-hash"

// MachineDeploymentSpec defines the desired state of MachineDeployment.
#MachineDeploymentSpec: {
	// ClusterName is the name of the Cluster this object belongs to.
	// +kubebuilder:validation:MinLength=1
	clusterName: string @go(ClusterName)

	// Number of desired machines.
	// This is a pointer to distinguish between explicit zero and not specified.
	//
	// Defaults to:
	// * if the Kubernetes autoscaler min size and max size annotations are set:
	//   - if it's a new MachineDeployment, use min size
	//   - if the replicas field of the old MachineDeployment is < min size, use min size
	//   - if the replicas field of the old MachineDeployment is > max size, use max size
	//   - if the replicas field of the old MachineDeployment is in the (min size, max size) range, keep the value from the oldMD
	// * otherwise use 1
	// Note: Defaulting will be run whenever the replicas field is not set:
	// * A new MachineDeployment is created with replicas not set.
	// * On an existing MachineDeployment the replicas field was first set and is now unset.
	// Those cases are especially relevant for the following Kubernetes autoscaler use cases:
	// * A new MachineDeployment is created and replicas should be managed by the autoscaler
	// * An existing MachineDeployment which initially wasn't controlled by the autoscaler
	//   should be later controlled by the autoscaler
	// +optional
	replicas?: null | int32 @go(Replicas,*int32)

	// RolloutAfter is a field to indicate a rollout should be performed
	// after the specified time even if no changes have been made to the
	// MachineDeployment.
	// Example: In the YAML the time can be specified in the RFC3339 format.
	// To specify the rolloutAfter target as March 9, 2023, at 9 am UTC
	// use "2023-03-09T09:00:00Z".
	// +optional
	rolloutAfter?: null | metav1.#Time @go(RolloutAfter,*metav1.Time)

	// Label selector for machines. Existing MachineSets whose machines are
	// selected by this will be the ones affected by this deployment.
	// It must match the machine template's labels.
	selector: metav1.#LabelSelector @go(Selector)

	// Template describes the machines that will be created.
	template: #MachineTemplateSpec @go(Template)

	// The deployment strategy to use to replace existing machines with
	// new ones.
	// +optional
	strategy?: null | #MachineDeploymentStrategy @go(Strategy,*MachineDeploymentStrategy)

	// MinReadySeconds is the minimum number of seconds for which a Node for a newly created machine should be ready before considering the replica available.
	// Defaults to 0 (machine will be considered available as soon as the Node is ready)
	// +optional
	minReadySeconds?: null | int32 @go(MinReadySeconds,*int32)

	// The number of old MachineSets to retain to allow rollback.
	// This is a pointer to distinguish between explicit zero and not specified.
	// Defaults to 1.
	// +optional
	revisionHistoryLimit?: null | int32 @go(RevisionHistoryLimit,*int32)

	// Indicates that the deployment is paused.
	// +optional
	paused?: bool @go(Paused)

	// The maximum time in seconds for a deployment to make progress before it
	// is considered to be failed. The deployment controller will continue to
	// process failed deployments and a condition with a ProgressDeadlineExceeded
	// reason will be surfaced in the deployment status. Note that progress will
	// not be estimated during the time a deployment is paused. Defaults to 600s.
	// +optional
	progressDeadlineSeconds?: null | int32 @go(ProgressDeadlineSeconds,*int32)
}

// MachineDeploymentStrategy describes how to replace existing machines
// with new ones.
#MachineDeploymentStrategy: {
	// Type of deployment.
	// Default is RollingUpdate.
	// +kubebuilder:validation:Enum=RollingUpdate;OnDelete
	// +optional
	type?: #MachineDeploymentStrategyType @go(Type)

	// Rolling update config params. Present only if
	// MachineDeploymentStrategyType = RollingUpdate.
	// +optional
	rollingUpdate?: null | #MachineRollingUpdateDeployment @go(RollingUpdate,*MachineRollingUpdateDeployment)
}

// MachineRollingUpdateDeployment is used to control the desired behavior of rolling update.
#MachineRollingUpdateDeployment: {
	// The maximum number of machines that can be unavailable during the update.
	// Value can be an absolute number (ex: 5) or a percentage of desired
	// machines (ex: 10%).
	// Absolute number is calculated from percentage by rounding down.
	// This can not be 0 if MaxSurge is 0.
	// Defaults to 0.
	// Example: when this is set to 30%, the old MachineSet can be scaled
	// down to 70% of desired machines immediately when the rolling update
	// starts. Once new machines are ready, old MachineSet can be scaled
	// down further, followed by scaling up the new MachineSet, ensuring
	// that the total number of machines available at all times
	// during the update is at least 70% of desired machines.
	// +optional
	maxUnavailable?: null | intstr.#IntOrString @go(MaxUnavailable,*intstr.IntOrString)

	// The maximum number of machines that can be scheduled above the
	// desired number of machines.
	// Value can be an absolute number (ex: 5) or a percentage of
	// desired machines (ex: 10%).
	// This can not be 0 if MaxUnavailable is 0.
	// Absolute number is calculated from percentage by rounding up.
	// Defaults to 1.
	// Example: when this is set to 30%, the new MachineSet can be scaled
	// up immediately when the rolling update starts, such that the total
	// number of old and new machines do not exceed 130% of desired
	// machines. Once old machines have been killed, new MachineSet can
	// be scaled up further, ensuring that total number of machines running
	// at any time during the update is at most 130% of desired machines.
	// +optional
	maxSurge?: null | intstr.#IntOrString @go(MaxSurge,*intstr.IntOrString)

	// DeletePolicy defines the policy used by the MachineDeployment to identify nodes to delete when downscaling.
	// Valid values are "Random, "Newest", "Oldest"
	// When no value is supplied, the default DeletePolicy of MachineSet is used
	// +kubebuilder:validation:Enum=Random;Newest;Oldest
	// +optional
	deletePolicy?: null | string @go(DeletePolicy,*string)
}

// MachineDeploymentStatus defines the observed state of MachineDeployment.
#MachineDeploymentStatus: {
	// The generation observed by the deployment controller.
	// +optional
	observedGeneration?: int64 @go(ObservedGeneration)

	// Selector is the same as the label selector but in the string format to avoid introspection
	// by clients. The string will be in the same format as the query-param syntax.
	// More info about label selectors: http://kubernetes.io/docs/user-guide/labels#label-selectors
	// +optional
	selector?: string @go(Selector)

	// Total number of non-terminated machines targeted by this deployment
	// (their labels match the selector).
	// +optional
	replicas: int32 @go(Replicas)

	// Total number of non-terminated machines targeted by this deployment
	// that have the desired template spec.
	// +optional
	updatedReplicas: int32 @go(UpdatedReplicas)

	// Total number of ready machines targeted by this deployment.
	// +optional
	readyReplicas: int32 @go(ReadyReplicas)

	// Total number of available machines (ready for at least minReadySeconds)
	// targeted by this deployment.
	// +optional
	availableReplicas: int32 @go(AvailableReplicas)

	// Total number of unavailable machines targeted by this deployment.
	// This is the total number of machines that are still required for
	// the deployment to have 100% available capacity. They may either
	// be machines that are running but not yet available or machines
	// that still have not been created.
	// +optional
	unavailableReplicas: int32 @go(UnavailableReplicas)

	// Phase represents the current phase of a MachineDeployment (ScalingUp, ScalingDown, Running, Failed, or Unknown).
	// +optional
	phase?: string @go(Phase)

	// Conditions defines current service state of the MachineDeployment.
	// +optional
	conditions?: #Conditions @go(Conditions)
}

// MachineDeploymentPhase indicates the progress of the machine deployment.
#MachineDeploymentPhase: string // #enumMachineDeploymentPhase

#enumMachineDeploymentPhase:
	#MachineDeploymentPhaseScalingUp |
	#MachineDeploymentPhaseScalingDown |
	#MachineDeploymentPhaseRunning |
	#MachineDeploymentPhaseFailed |
	#MachineDeploymentPhaseUnknown

// MachineDeploymentPhaseScalingUp indicates the MachineDeployment is scaling up.
#MachineDeploymentPhaseScalingUp: #MachineDeploymentPhase & "ScalingUp"

// MachineDeploymentPhaseScalingDown indicates the MachineDeployment is scaling down.
#MachineDeploymentPhaseScalingDown: #MachineDeploymentPhase & "ScalingDown"

// MachineDeploymentPhaseRunning indicates scaling has completed and all Machines are running.
#MachineDeploymentPhaseRunning: #MachineDeploymentPhase & "Running"

// MachineDeploymentPhaseFailed indicates there was a problem scaling and user intervention might be required.
#MachineDeploymentPhaseFailed: #MachineDeploymentPhase & "Failed"

// MachineDeploymentPhaseUnknown indicates the state of the MachineDeployment cannot be determined.
#MachineDeploymentPhaseUnknown: #MachineDeploymentPhase & "Unknown"

// MachineDeployment is the Schema for the machinedeployments API.
#MachineDeployment: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta       @go(ObjectMeta)
	spec?:     #MachineDeploymentSpec   @go(Spec)
	status?:   #MachineDeploymentStatus @go(Status)
}

// MachineDeploymentList contains a list of MachineDeployment.
#MachineDeploymentList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#MachineDeployment] @go(Items,[]MachineDeployment)
}
